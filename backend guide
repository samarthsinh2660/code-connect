things to remeber while creating the backend 

1. create in the mongo db or mysql which is best for this app
2. create in the typescript 
3. in the utils create the custrom error file jwt file this the example of this file take the reference of this files 
  jwt.ts 
  import jwt, { SignOptions } from 'jsonwebtoken';
import { ERRORS } from './error.ts';
import { JWT_SECRET, JWT_EXPIRES_IN } from '../config/env.ts';
import { JWT_REFRESH_EXPIRES_IN } from '../config/env.ts';



export interface TokenData {
    id: number;
    is_master: boolean;
    email?: string;
    username?: string;
    name?: string;
    // Multi-tenant fields
    factory_db?: string;
    role?: string;
}

export function createAuthToken(user: TokenData): string {
    if (!JWT_SECRET) {
        throw ERRORS.JWT_SECRET_NOT_CONFIGURED;
    }
    if (!JWT_EXPIRES_IN) {
        throw ERRORS.JWT_SECRET_NOT_CONFIGURED;
    }
    
    const token = jwt.sign(user, JWT_SECRET, {
        expiresIn: JWT_EXPIRES_IN
    } as SignOptions);
    
    return token;
}

export function createRefreshToken(user: TokenData): string {
    if (!JWT_SECRET) {
        throw ERRORS.JWT_SECRET_NOT_CONFIGURED;
    }
    if (!JWT_REFRESH_EXPIRES_IN) {
        throw ERRORS.JWT_SECRET_NOT_CONFIGURED;
    }
    
    // Using same secret for simplicity, but in production you might want separate secrets
    const token = jwt.sign(user, JWT_SECRET, {
        expiresIn: JWT_REFRESH_EXPIRES_IN
    } as SignOptions);
    
    return token;
}

export function decodeAuthToken(token: string): TokenData {
    if (!JWT_SECRET) {
        throw ERRORS.JWT_SECRET_NOT_CONFIGURED;
    }
    
    try {
        const decoded = jwt.verify(token, JWT_SECRET);
        
        if (typeof decoded === 'string') {
            throw ERRORS.INVALID_AUTH_TOKEN;
        }
        
        return decoded as TokenData;
    } catch (error) {
        if (error instanceof jwt.TokenExpiredError) {
            throw ERRORS.TOKEN_EXPIRED;
        }
        throw ERRORS.INVALID_AUTH_TOKEN;
    }
}

export function decodeRefreshToken(token: string): TokenData {
    if (!JWT_SECRET) {
        throw ERRORS.JWT_SECRET_NOT_CONFIGURED;
    }
    
    try {
        const decoded = jwt.verify(token, JWT_SECRET);
        
        if (typeof decoded === 'string') {
            throw ERRORS.INVALID_REFRESH_TOKEN;
        }
        
        return decoded as TokenData;
    } catch (error) {
        throw ERRORS.INVALID_REFRESH_TOKEN;
    }
}

error.ts
export class RequestError extends Error {
    code: number;
    statusCode: number;
    
    constructor(message: string, code: number, statusCode: number) {
        super(message);
        this.name = 'RequestError';
        this.code = code;
        this.statusCode = statusCode;
        
        // Maintains proper stack trace for where our error was thrown (only available on V8)
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, RequestError);
        }
    }
}

/*
HTTP Status Codes Reference:
200 OK - Response to a successful GET, PUT, PATCH or DELETE
201 Created - Response to a POST that results in a creation
204 No Content - Response to a successful request that won't be returning a body
304 Not Modified - Used when HTTP caching headers are in play
400 Bad Request - The request is malformed, such as if the body does not parse
401 Unauthorized - When no or invalid authentication details are provided
403 Forbidden - When authentication succeeded but authenticated user doesn't have access to the resource
404 Not Found - When a non-existent resource is requested
405 Method Not Allowed - When an HTTP method is being requested that isn't allowed for the authenticated user
410 Gone - Indicates that the resource at this end point is no longer available
415 Unsupported Media Type - If incorrect content type was provided as part of the request
422 Unprocessable Entity - Used for validation errors
429 Too Many Requests - When a request is rejected due to rate limiting
500 Internal Server Error - This is either a system or application error
503 Service Unavailable - The server is unable to handle the request for a service due to temporary maintenance
*/

/*
Error Code Convention:
- 1xxxx: Common/General errors
- 2xxxx: Authentication & Authorization errors  
- 3xxxx: product management errors
- 4xxxx: location management errors
- 5xxxx: subcategory management errors
- 6xxxx: formula management errors
- 7xxxx: inventory entry management errors
- 8xxxx: audit log management errors
- 9xxxx: alert and notification management errors
- 10xxxx: factory invoice management erros 
- 11xxxx:  Invoice Management errors
- 12xxxx: tax component management errors
*/

export const ERRORS = {
    // Common Errors (1xxxx)
    DATABASE_ERROR: new RequestError("Database operation failed", 10001, 500),
    INVALID_REQUEST_BODY: new RequestError("Invalid request body", 10002, 400),
    INVALID_QUERY_PARAMETER: new RequestError("Invalid query parameters", 10003, 400),
    UNHANDLED_ERROR: new RequestError("An unexpected error occurred", 10004, 500),
    INTERNAL_SERVER_ERROR: new RequestError("Internal server error", 10005, 500),
    FILE_NOT_FOUND: new RequestError("File not found", 10006, 404),
    INVALID_PARAMS: new RequestError("Invalid parameters", 10007, 400),
    VALIDATION_ERROR: new RequestError("Validation failed", 10008, 422),
    RESOURCE_NOT_FOUND: new RequestError("Resource not found", 10009, 404),
    DUPLICATE_RESOURCE: new RequestError("Resource already exists", 10010, 409),
    RESOURCE_ALREADY_EXISTS: new RequestError("Resource already exists", 10010, 409),
    RESOURCE_IN_USE: new RequestError("Resource is in use and cannot be deleted", 10011, 400),
    PAGE_MUST_BE_POSITIVE_INTEGER: new RequestError("Page must be a positive integer", 10012, 400),
    
    // User Management Errors (11xxx)
    INVALID_ROLE: new RequestError("Invalid role value. Allowed values: 'master', 'employee'", 11001, 400),
    INVALID_USER_OPERATION: new RequestError("Invalid operation on user account", 11002, 400),
    CANNOT_DELETE_OWN_ACCOUNT: new RequestError("Cannot delete your own account", 11003, 403),
    CANNOT_CHANGE_OWN_ROLE: new RequestError("Cannot change your own role", 11004, 403),
    USERNAME_ALREADY_EXISTS: new RequestError("Username already exists", 11005, 409),
    EMAIL_ALREADY_EXISTS: new RequestError("Email already exists", 11006, 409),
    USER_NOT_FOUND: new RequestError("User not found", 11007, 404),
    INVALID_USERNAME_FORMAT: new RequestError("Invalid username format", 11008, 400),
    USER_CREATION_MASTER_ONLY: new RequestError("Only master users can create new accounts", 11009, 403),
    // Authentication & Authorization Errors (2xxxx)

    } as const;

// Helper function to check if error is a RequestError
export function isRequestError(error: any): error is RequestError {
    return error instanceof RequestError;
}

reposne.ts 


// Standard success response format
export function successResponse(data: any, message?: string) {
    return {
        success: true,
        message: message || "Operation successful",
        data,
        timestamp: new Date().toISOString()
    };
}

// Standard error response format
export function errorResponse(message: string, code: number = 10000) {
    return {
        success: false,
        error: {
            code,
            message
        },
        timestamp: new Date().toISOString()
    };
}


// Response for list operations without pagination
export function listResponse(data: any[], message?: string, meta?: any) {
    return {
        success: true,
        message: message || "Data retrieved successfully",
        data,
        meta: meta || { count: data.length },
        timestamp: new Date().toISOString()
    };
}

// Response for creation operations
export function createdResponse(data: any, message?: string) {
    return {
        success: true,
        message: message || "Resource created successfully",
        data,
        timestamp: new Date().toISOString()
    };
}

// Response for update operations
export function updatedResponse(data: any, message?: string) {
    return {
        success: true,
        message: message || "Resource updated successfully",
        data,
        timestamp: new Date().toISOString()
    };
}

// Response for delete operations
export function deletedResponse(message?: string) {
    return {
        success: true,
        message: message || "Resource deleted successfully",
        timestamp: new Date().toISOString()
    };
}

// Response for authentication operations
export function authResponse(data: { user: any, token: string }, message?: string) {
    return {
        success: true,
        message: message || "Authentication successful",
        data: {
            user: data.user,
            token: data.token
        },
        timestamp: new Date().toISOString()
    };
}

// Response with custom metadata
export function responseWithMeta(
    data: any,
    meta: any,
    message?: string
) {
    return {
        success: true,
        message: message || "Operation successful",
        data,
        meta,
        timestamp: new Date().toISOString()
    };
}

// Empty success response
export function emptyResponse(message?: string) {
    return {
        success: true,
        message: message || "Operation completed successfully",
        timestamp: new Date().toISOString()
    };
}

// Search response with search metadata
export function searchResponse(
    data: any[],
    searchMeta: {
        query: string;
        totalResults: number;
        searchTime?: number;
        filters?: any;
    },
    message?: string
) {
    const response: any = {
        success: true,
        message: message || "Search completed successfully",
        data,
        searchMeta,
        timestamp: new Date().toISOString()
    };


    return response;
}


in the oncifg folder 
env .ts import { config } from "dotenv";
import path from "path";
import { fileURLToPath } from 'url';

// ES Module equivalent of __dirname
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Look for the .env file in the project root
const envPath = path.join(__dirname, '..', '..', `.env.${process.env.NODE_ENV || 'development'}.local`);
const result = config({ path: envPath });

if (result.error) {
  console.warn(`Warning: Environment file not found or couldn't be loaded`);
}

// Required string values
export const PORT = process.env.PORT;
export const NODE_ENV = process.env.NODE_ENV;
export const SERVER_URL = process.env.SERVER_URL;

// Base file name used for backups (e.g., multi_tenant_backup)
export const BACKUP_BASE_NAME = process.env.BACKUP_BASE_NAME || 'multi_tenant_backup';

// Azure Blob Storage configuration
export const AZURE_STORAGE_ACCOUNT_NAME = process.env.AZURE_STORAGE_ACCOUNT_NAME;
export const AZURE_STORAGE_ACCOUNT_KEY = process.env.AZURE_STORAGE_ACCOUNT_KEY;
export const AZURE_STORAGE_CONTAINER_NAME = process.env.AZURE_STORAGE_CONTAINER_NAME || 'database-backups';
export const AZURE_BACKUP_ENABLED = process.env.AZURE_BACKUP_ENABLED === 'true';

export const DB_HOST = process.env.DB_HOST!;
export const DB_USER = process.env.DB_USER!;
export const DB_PASSWORD = process.env.DB_PASSWORD!;
export const DB_NAME = process.env.DB_NAME!;
export const DB_PORT = parseInt(process.env.DB_PORT || '3306', 10);

// JWT: assert that these are defined
export const JWT_SECRET = process.env.JWT_SECRET!;
export const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN;
export const JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN;

//cors
export const CORS_ORIGIN = process.env.CORS_ORIGIN;
export const CORS_ORIGIN1 = process.env.CORS_ORIGIN1;
export const CORS_ORIGIN2 = process.env.CORS_ORIGIN2;
export const CORS_ORIGIN3 = process.env.CORS_ORIGIN3;
export const CORS_ORIGIN4 = process.env.CORS_ORIGIN4;
export const CORS_ORIGIN5 = process.env.CORS_ORIGIN5;
export const CORS_ORIGIN6 = process.env.CORS_ORIGIN6;

// Tenant DB admin (used only for provisioning tenant databases)
export const TENANT_DB_ADMIN_USER = process.env.TENANT_DB_ADMIN_USER;
export const TENANT_DB_ADMIN_PASSWORD = process.env.TENANT_DB_ADMIN_PASSWORD;

// MySQL/Backup env for backup.service
export const MYSQL_HOST = process.env.MYSQL_HOST;
export const MYSQL_PORT = parseInt(process.env.MYSQL_PORT || '3306', 10);
export const MYSQL_USER = process.env.MYSQL_USER;
export const MYSQL_PASSWORD = process.env.MYSQL_PASSWORD;
export const BACKUP_RETENTION_DAYS = parseInt(process.env.BACKUP_RETENTION_DAYS || '7', 10);

3. use the rate limite middlewate 
4. use the auth middleware  like this 
import { Request, Response, NextFunction } from 'express';
import { decodeAuthToken, TokenData } from '../utils/jwt.ts';
import { ERRORS } from '../utils/error.ts';
import { getPoolByUsername } from '../database/connectionManager.ts';
import { Pool } from 'mysql2/promise';
import '../types/express.ts';
import createLogger from '../utils/logger.js';

const logger = createLogger('@auth');

export const authenticate = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
        const authHeader = req.headers['authorization'];
        const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

        if (!token) {
            throw ERRORS.NO_TOKEN_PROVIDED;
        }

        const decoded = decodeAuthToken(token) as TokenData;
        
        // Multi-tenant only - all tokens must have factory_db
        if (!decoded.factory_db || !decoded.username || !decoded.username.includes('@')) {
            throw ERRORS.INVALID_AUTH_TOKEN;
        }
        
        // Attach user info to request
        req.user = decoded;
        
        // Initialize factory pool immediately
        try {
            (req as any).factoryPool = await getFactoryPoolFromRequest(req);
            (req as any).factoryDbName = decoded.factory_db;
        } catch (error) {
            logger.error(`❌ Failed to initialize factory pool for ${decoded.factory_db}:`, error);
            throw ERRORS.INVALID_AUTH_TOKEN;
        }
        
        next();
    } catch (error) {
        next(error);
    }
};

export const requireMaster = (req: Request, res: Response, next: NextFunction): void => {
    try {
        if (!req.user) {
            throw ERRORS.UNAUTHORIZED;
        }

        if (!req.user.is_master) {
            throw ERRORS.ADMIN_ONLY_ROUTE;
        }

        next();
    } catch (error) {
        next(error);
    }
};

// Helper function to get factory pool for a request (for repositories)
export const getFactoryPoolFromRequest = async (req: Request): Promise<Pool> => {
    const user = req.user as TokenData;
    if (!user || !user.username || !user.factory_db) {
        throw new Error('User not authenticated or missing factory context');
    }

    // Get pool directly using the username
    return await getPoolByUsername(user.username);
};

// Any authenticated user middleware (master or employee)
export const requireAuth = (req: Request, res: Response, next: NextFunction): void => {
    try {
        if (!req.user) {
            throw ERRORS.UNAUTHORIZED;
        }
        next();
    } catch (error) {
        next(error);
    }
};

// Alias for backward compatibility
export const authenticateMultiTenant = authenticate;
export const requireMultiTenantMaster = requireMaster;


4. create the cutsome error middleware so wwe use next (error) and next throw error 
import { Request, Response, NextFunction, ErrorRequestHandler } from 'express';
import { RequestError } from '../utils/error.ts';
import { errorResponse } from '../utils/response.ts';
import { NODE_ENV } from '../config/env.ts';
import createLogger from '../utils/logger.js';

const localLogger = createLogger('@error');

export const errorHandler = (
    error: Error | RequestError,
    req: Request,
    res: Response,
    next: NextFunction
): void => {
  // Log error with structured logging
  localLogger.error(`Error occurred: ${error.message}`, {
    stack: error.stack,
    url: req.url,
    method: req.method,
    body: req.body,
    params: req.params,
    query: req.query,
    timestamp: new Date().toISOString(),
  });

  // Handle RequestError (our custom errors)
  if (error instanceof RequestError) {
    res.status(error.statusCode).json(
      errorResponse(error.message, error.code)
    );
    return;
  }

  // Handle JWT specific errors
  if (error.name === 'JsonWebTokenError') {
    res.status(401).json(
      errorResponse('Invalid authentication token', 20002)
    );
    return;
  }

  if (error.name === 'TokenExpiredError') {
    res.status(401).json(
      errorResponse('Authentication token has expired', 20003)
    );
    return;
  }

  // Handle database errors (MySQL/generic)
  if (error.message.includes('ER_DUP_ENTRY')) {
    res.status(409).json(
      errorResponse('Duplicate entry detected', 10001)
    );
    return;
  }

  if (error.message.includes('ER_NO_REFERENCED_ROW')) {
    res.status(400).json(
      errorResponse('Referenced record not found', 10001)
    );
    return;
  }

  // Handle validation errors (if using express-validator)
  if (error.name === 'ValidationError') {
    res.status(422).json(
      errorResponse(error.message, 10008)
    );
    return;
  }

  // Handle syntax errors in JSON
  if (error instanceof SyntaxError && 'body' in error) {
    res.status(400).json(
      errorResponse('Invalid JSON in request body', 10002)
    );
    return;
  }

  // Handle any other unexpected errors
  res.status(500).json(
    errorResponse(
      NODE_ENV === 'production'
        ? 'Internal server error'
        : error.message,
      10004
    )
  );
  // void return
};

// 404 Not Found handler
export const notFoundHandler = (req: Request, res: Response) => {
    res.status(404).json(
        errorResponse(`Route ${req.method} ${req.path} not found`, 10006)
    );
};



5. use the controller and all like this 
import { Request, Response, NextFunction } from 'express';
import bcrypt from 'bcrypt';
import { createAuthToken, createRefreshToken, TokenData, decodeAuthToken } from '../utils/jwt.ts';
import { successResponse } from '../utils/response.ts';
import { ERRORS } from '../utils/error.ts';
import { userRepository } from '../repositories/user.repository.ts';
import { extractFactoryFromUsername, getPoolByUsername, healthCheckPools, getPoolStats } from '../database/connectionManager.ts';
import { FactoryRepository } from '../repositories/factory.repository.ts';
import createLogger from '../utils/logger.ts';
 
const logger = createLogger('@authController');

export const signup = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
        const { name, role, username, password, email } = req.body;
        const currentUser = req.user as TokenData;

        // Validation
        if (!name || !role || !username || !password) {
            throw ERRORS.INVALID_REQUEST_BODY;
        }

        if (!['master', 'employee'].includes(role)) {
            throw ERRORS.INVALID_ROLE;
        }

        // Only masters can create users
        if (!currentUser.is_master) {
            throw ERRORS.USER_CREATION_MASTER_ONLY;
        }

        // Ensure factory context exists
        if (!currentUser.factory_db) {
            throw ERRORS.FACTORY_CONTEXT_REQUIRED;
        }

        // Username should NOT contain @ (we'll add factory suffix)
        if (username.includes('@')) {
            throw ERRORS.INVALID_USERNAME_FORMAT;
        }

        // Check if user already exists in this factory
        const existingUser = await userRepository.findByUsername(username, req);
        if (existingUser) {
            throw ERRORS.USERNAME_ALREADY_EXISTS;
        }

        // Hash password
        const saltRounds = 12;
        const hashedPassword = await bcrypt.hash(password, saltRounds);

        // Create user in factory database
        const user = await userRepository.create({
            name,
            username,
            password: hashedPassword,
            email,
            role,
        }, req);

        // User response (without password)
        const userResponse = {
            id: user.id,
            name: user.name,
            role: user.role,
            username: `${user.username}@${currentUser.factory_db}`, // Full username for display
            display_username: user.username, // Clean username for UI
            ...(user.email && { email: user.email }),
            created_at: user.created_at
        };

        res.status(201).json(
            successResponse(userResponse, `${role === 'master' ? 'Master' : 'Employee'} account created successfully`)
        );
    } catch (error) {
        logger.warn('signup error:', error as any);
        next(error);
    }
};